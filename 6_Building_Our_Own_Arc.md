# 第六章：构建我们自己的“Arc”

在[第一章“引用计数”](./1_Basic_of_Rust_Concurrency.md#引用计数)中，我们了解了 `std::sync::Arc<T>` 类型允许通过引用计数共享所有权。`Arc::new` 函数创建一个新的分配，就像 `Box::new`。然而，与 Box 不同的是，克隆 Arc 将共享原始分配，而不是创建一个新的。只有当 Arc 和所有其他的克隆被 drop，共享分配才会被 drop。

这种类型的实现所涉及的内存排序可能是非常有趣的。在本章中，我们将通过实现我们自己的 `Arc<T>` 将更多理论付诸实践。我们将开始一个基础的版本，然后将其扩展到支持循环结构的 *weak 指针*，并且最终将其优化为一个与标准库差不多的实现结束本章。

## 基础的引用计数

### 测试它

### 可变性

## Weak 指针

### 测试它2

### 优化

## 总结

* `Arc<T>` 提供一个引用计数分配的共享所有权。
* 通过检查引用计数是否确实是一个 `Arc<T>`，可以有条件地提供独占访问（`&mut T`）。
* 增加原子引用计数可以使用 relaxed 操作，但是最终的递减必须与之前的递减同步。
* *weak 指针*（`Weak<T>`）可以用于避免循环。
* `NonNull<T>` 类型表示一个指向 T 的指针，但是从不是空。
* `ManuallyDrop<T>` 类型可以用于使用不安全代码时，手动决定何时 drop T。
* 一旦涉及一个以上的原子变量，事情就会变得更加复杂。
* 实现特定的（自旋）锁有时可能是同时对多个原子变量进行操作的有效策略。

<p style="text-align: center; padding-block-start: 5rem;">
  <a href="./7_Understanding_the_Processor.html">下一篇，第七章：理解处理器</a>
</p>
