# 第一章：Rust 并发基础

早在多核处理器司空见惯之前，操作系统就允许一台计算机运行多个程序。这是通过在进程之间快速切换来完成的，允许每个进程逐个地重重地取得一点进展。现在，几乎所有的电脑，甚至手机和手表都有着多核处理器，可以真正并行执行多个程序。

操作系统尽可能的将进程之间隔离，允许程序完全意识不到其他线程在做什么的情况下做自己的事情。例如，在不先询问操作系统内核的情况下，一个进程通常不能获取其他进程的内存，或者以任意方式与之通信。

然而，一个程序可以产生额外的*执行线程*作为*进程*的一部分。同一进程中的线程不会相互隔离。线程共享内存并且可以通过内存相互交互。

这一章节将阐述在 Rust 中如何产生线程，并且关于它们的所有基本概念，例如如何安全地在多个线程之间共享数据。本章中解释的概念是本书其余部分的基础。

> 如果你已经熟悉 Rust 中的这些部分，你可以随时跳过。然而，在你继续下一章节之前，请确保你对线程、内部可变性、Send 和 Sync 有一个好的理解，以及知道什么是互斥锁[^2]、条件变量[^1]以及线程阻塞（park）[^3]。

## Rust 中的线程

## 线程作用域

## 共享所有权以及引用计数

### Static

### 泄漏（Leak）

### 引用计数

## 借用和数据竞争

## 内部可变性

### Cell

### RefCell

### 互斥锁[^4]和读写锁[^5]

### Atomic

### UnsafeCell

## 线程安全：Send 和 Sync

## 锁：互斥锁和读写锁

### Rust 的互斥锁

### 锁毒化

### 读写锁

## 等待: 阻塞（Park）和条件变量

### 线程阻塞

### 条件变量

## 总结

[^1]: <https://zh.wikipedia.org/zh-cn/監視器_(程序同步化)>
[^2]: <https://zh.wikipedia.org/wiki/互斥锁>
[^3]: <https://rustwiki.org/zh-CN/std/thread/fn.park.html>
[^4]: <https://zh.wikipedia.org/wiki/互斥锁>
[^5]: <https://zh.wikipedia.org/wiki/读写锁>
