# 第五章：构建我们自己的 Channel

*Channel* 可以被用于在线程之间发送数据，并且它们有很多变体。一些 channel 仅能在一个发送方和一个接收方之间使用，而另一些可以在任意数量的线程之间发送，或者甚至允许多个接收放。一些 channel 是阻塞的，这意味着接收（有时也包括发送）是一个阻塞操作，这会使线程进入睡眠状态，知道你的操作完成。一些 channel 针对团兔粮进行优化，而另一些针对低延迟进行优化。

这些变体是无穷尽的，没有一种通用版本在所有场景都适合的。

在该章节，我们将实现一个相对简单的 channel，不仅可以探索更多的原子应用，同时也可以了解如何在 Rust 类型系统中捕获我们的需求和假设。

## 一个简单的以 mutex 为基础的 Channel

## 一个不安全的一次性 Channel

## 通过运行时检查来达到安全

## 通过类型来达到安全

## 借用以避免分配

## 阻塞

## 总结

* *channel* 用于在线程之间发送*消息*。
* 一个简单、灵活但可能效率低下的 channel，只需一个 `Mutex` 和 `Condvar` 就很容易实现。
* *一次性*（one-shot）channel 是一个被设计仅发送一次信息的 channel。
* `MaybeUninit<T>` 类型可用于表示可能尚未初始化的 `T`。其接口大多不安全，使用户负责跟踪其是否已初始化，不要复制非 `Copy` 数据，并在必要时删除其内容。
* 不 drop 对象（也称为泄漏或者遗忘）是安全的，但如果没有充分理由而这样做，会被视为不良的做法。
* panic 是创建安全接口的重要工具。
* 按值获取一个非 Copy 对象可以用于阻止某个操作被重复执行。
* 独占借用和拆分借用是确保正确性的强大工具。
* 我们可以确保对象的类型不实现 `Send`，确保它在同一个线程，这可以通过 `PhantomData` 标记实现。
* 每个设计和实施决定都涉及权衡，最好在考虑特定用例的情况下做出。
* 在没有用例的情况下设计一些东西可能是有趣的和有教育意义的，但是这可能是一个无止境的任务。

<p style="text-align: center; padding-block-start: 5rem;">
  <a href="./6_Building_Our_Own_Arc.html">下一篇，第六章：构建我们自己的“Arc”</a>
</p>
