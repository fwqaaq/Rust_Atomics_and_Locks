# 第二章：Atomic

*原子*（atomic）这个单词来自于希腊语 `ἄτομος`，意味着不可分割的，不能被切割成更小的块。在计算机科学中，它被用于描述一个不可分割的操作：它要么完全完成，要么还没发生。

正如在[第一章“借用和数据竞争”](./1_Basic_of_Rust_Concurrency.md#借用和数据竞争)中提及的，多线程并发地读取和修改相同的变量会导致未定义行为。然而，原子操作确实允许不同线程去安全地读取和修改相同的变量。因为该操作是不可分割的，它要么完全地在一个操作之前完成，要么在另一个操作之后完成，从而避免未定义行为。稍后，[在第七章](./7_Understanding_the_Processor.md)，我们将在硬件层面查看它们是如何工作的。

原子操作是任何涉及多线程的主要基石。所有其它的并发原语，例如互斥锁，条件变量都使用原子操作实现。

在 Rust 中，原子操作可以作为 `std::sync::atomic` 标准原子类型的方法使用。它们的名称都以 Atomic 开头，例如 AtomicI32 或 AtomicUsize。可用的原子类型取决于硬件架构和一些操作系统，但几乎所有的平台都提供了指针大小的所有原子类型。

与大多数类型不同，它们允许通过共享引用进行修改（例如，`&AtomicU8`）。正如[第一章“内部可变性”](./1_Basic_of_Rust_Concurrency.md#内部可变性)讨论的那样，这都要归功于它。

每一个可用的原子类型都有着相同的接口，包括存储（store）和加载（load）、原子“获取和修改（fetch-and-modify）”操作方法、和一些更高级的“比较和交换（compare-and-exchange）”方法。我们将在这章节的后半部分讨论它们。

但是，在我们研究不同原子操作之前，我们需要简要谈谈叫做*内存排序*[^1]的概念：

每一个原子操作都采用了 `std::sync::atomic::Ordering` 类型的参数，这决定了我们对操作相对排序的保证。保证最少的简单变体是 `Relaxed`。`Relaxed` 只保证在单个原子变量中的一致性，但是在不同变量的相对操作顺序没有任何承诺。

这意味着两个线程可能看到不同变量的操作以不同的顺序下发生。例如，如果一个线程首先写入一个变量，然后非常快速的写入第二个变量，另一个线程可能看见这以相反的顺序发生。

在这章节，我们将仅关注不会出现问题的使用情况，并且在所有地方都简单地使用 `Relaxed`，而不深入讨论更多细节。我们将在[第三章](./3_Memory_Ordering.md)讨论内存排序的所有细节以及其它可用内存排序。

## Atomic 的加载和存储操作

### 示例：停止标识

### 示例：进度报道

#### 同步

### 示例：惰性初始化

## 获取并修改操作

### 示例：来自多线程的进度报道

### 示例：统计数据

### 示例：ID 分配

## compare-and-exchange 操作

### 示例：没有溢出的 ID 分配

### 示例：惰性一次性初始化

## 总结

* 原子操作是不可分割的；它们要么完整的完成，要么它们还没有发生。
* 在 Rust 中的原子操作是通过 `std::sync::atomic` 原子类型完成的，例如 `AtomicI32`。
* 不是所有原子类型在所有平台都是可获得的。
* 当涉及多个变量时，原子操作的相对顺序是棘手的。更多细节，请看[第三章](./3_Memory_Ordering.md)。
* 简单的 load 和 store 操作非常适合非常简单的基本线程间通信，例如停止标识和状态报道。
* 我们可以使用竞争条件[^2]来惰性始化，而不会引发数据竞争[^3]。
* 获取并修改操作允许进行一小组基本的原子修改操作，当多个线程同时修改同一个院子变量时，非常有用。
* 原子加法和减法在溢出时会默默地进行环绕（wrap around）操作。
* compare-and-exchange 操作是最灵活和通用的，并且是任意其它原子操作的基石。
* *weak* compare-and-exchange 稍微更有效。

[^1]: <https:·//zh.wikipedia.org/wiki/内存排序>
[^2]: 竞争条件是指多个线程并发访问和修改共享数据时，其最终结果依赖于线程执行的具体顺序。在某些情况下，我们可以利用竞争条件来实现延迟初始化。也就是说，多个线程可以同时尝试对共享资源进行初始化，但只有第一个成功的线程会完成初始化，而其他线程会放弃初始化操作。
[^3]: 数据竞争是指多个线程同时访问共享数据，并且至少有一个线程进行写操作，而没有适当的同步机制来保证正确的访问顺序。
