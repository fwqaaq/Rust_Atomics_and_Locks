# 第八章：操作系统原语

目前，我们主要聚焦在非阻塞的操作中。如果我们想要实现一些类似互斥锁或者条件变量的内容，也就是能够等待另一个线程去解锁或者通知它的内容，我们需要一种有效地阻塞当前线程的方式。

正如我们在[第四章](./4_Building_Our_Own_Spin_Lock.md)所见到的，我们可以不依赖操作系统，通过自旋，重复地一遍又一遍地尝试某些操作，自己实现阻塞，但这浪费大量的处理器时间。如果我们想要高效地进行阻塞，我们需要操作系统内核的帮助。

内核，或者更具体地说是其中的调度部分，负责决定哪个进程或者线程在何时运行，运行多长时间，并且在哪个处理器核心运行。尽管线程在等待某个事件发生时，内核可以停止，并给它任意的处理器时间，优先考虑其他能更好地利用这个有限资源的线程。

我们将需要一种方式来通知内核我们正在等待某个事件，并要求它将我们的线程置于睡眠状态，直到发生相关的事情。

## 使用内核接口

## POSIX

### 在 Rust 中包裹

## Linux

### Futex

### Futex 操作

### 优先继承 Futex 操作

## macOS

### os_unfair_lock

## Windows

### 重量级内核对象

### 轻量级对象

#### 一个轻巧的读写锁

### 基于地址的等待

## 总结

* *系统调用*（syscall）是进入操作系统内核的调用，与普通函数调用相比，相对较慢。
* 通常，程序不直接进行系统调用，而是通过操作系统的库（如 `libc`）与内核进行交互。在许多操作系统中，这是与内核进行交互的唯一支持方式。
* libc crate 提供了 Rust 代码访问 libc 的能力。
* 在 POSIX 系统上，libc 包含了不仅符合 C 标准所需的内容，还符合 POSIX 标准的内容。
* POSIX 标准包括 *pthread*，这是一个具有并发原语（如 `pthread_mutex_t`）的库。
* pthread 类型是为 C 设计的，而不是为 Rust 设计的。例如，它们不可移动，这可能是一个问题。
* Linux 有一个 *futex* 系统调用，支持在 AtomicU32 上进行几种等待和唤醒操作。等待操作验证原子的期望值，以避免错过通知。
* 除了 pthread，macOS 还提供了 `os_unfair_lock` 作为轻量级锁定原语。
* Windows 的重量级并发原语始终需要与内核进行交互，但可以在进程之间传递，并与标准的 Windows 等待函数一起使用。
* Windows 的轻量级并发原语包括“slim”读写锁（SRW 锁）和条件变量。这些可以很容易地在 Rust 中包装，因为它们是可移动的。
* Windows 还通过 WaitOnAddress 和 WakeByAddress 提供了类似 futex 的基本功能。

<p style="text-align: center; padding-block-start: 5rem;">
  <a href="./9_Building_Our_Own_Locks.html">下一篇，第九章：构建我们自己的「锁」</a>
</p>
